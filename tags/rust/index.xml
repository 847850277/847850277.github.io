<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0">
    <channel>
        <title>Rust - Tag - ZhengPengDe Blog</title>
        <link>https://847850277.github.io/tags/rust/</link>
        <description>Rust - Tag - ZhengPengDe Blog</description>
        <generator>Hugo -- gohugo.io</generator><language>zh-cn</language><lastBuildDate>Sun, 01 Jun 2025 09:00:00 &#43;0000</lastBuildDate><atom:link href="https://847850277.github.io/tags/rust/" rel="self" type="application/rss+xml" /><item>
    <title>Rust GUI</title>
    <link>https://847850277.github.io/posts/rust-gui/gpui/</link>
    <pubDate>Sun, 01 Jun 2025 09:00:00 &#43;0000</pubDate>
    <author>zhengpengde</author>
    <guid>https://847850277.github.io/posts/rust-gui/gpui/</guid>
    <description><![CDATA[Rust GUI 使用 gpui Render 和 Render Once 的区别 Render：
持续渲染模式
组件会在每一帧都重新渲染 适用于需要频繁更新的动态内容 消耗更多资源，但能保持实时更新 Render Once：
一次性渲染模式
组件只在初始化或状态变化时渲染 适用于静态内容或不频繁更新的组件 性能更好，资源消耗更少 在 GPUI 中选择合适的渲染模式可以优化应用性能和用户体验。 Entity 是什么
Entity 是 GPUI 框架中的一个智能指针类型，类似于 React 中的引用机制。它用于管理 UI 组件的生命周期和状态。
Entity 的主要用法 1. 创建 Entity Entity 通过 cx.new() 方法创建，接受一个闭包来初始化组件：
pub fn view(window: &amp;mut Window, cx: &amp;mut App) -&gt; Entity&lt;Self&gt; { cx.new(|cx| Self::new(window, cx)) } 2. 在结构体中存储 Entity Entity 常被用作结构体字段，用于持有子组件的引用：
pub struct Example { root: Entity&lt;ButtonStory&gt;, } 3. 在构造函数中创建子组件 impl Example { pub fn new(window: &amp;mut Window, cx: &amp;mut Context&lt;Self&gt;) -&gt; Self { let root = ButtonStory::view(window, cx); Self { root } } 4.]]></description>
</item>
<item>
    <title>锈迹片段</title>
    <link>https://847850277.github.io/posts/rust-snippet/rust-snippet/</link>
    <pubDate>Mon, 04 Nov 2024 10:00:00 &#43;0000</pubDate>
    <author>zhengpengde</author>
    <guid>https://847850277.github.io/posts/rust-snippet/rust-snippet/</guid>
    <description><![CDATA[Rust Snippet 锈迹片段 如何调试Rust过程属性宏的代码 通过println!(),可以打印出宏展开后的代码。
fn generate_handler(internal: bool, input: TokenStream) -&gt; Result&lt;TokenStream&gt; { let crate_name = utils::get_crate_name(internal); println!(&#34;crate_name: {:?}&#34;, crate_name); let item_fn = syn::parse::&lt;ItemFn&gt;(input)?; let (impl_generics, type_generics, where_clause) = item_fn.sig.generics.split_for_impl(); let vis = &amp;item_fn.vis; let docs = item_fn .attrs .iter() .filter(|attr| attr.path().is_ident(&#34;doc&#34;)) .cloned() .collect::&lt;Vec&lt;_&gt;&gt;(); let ident = &amp;item_fn.sig.ident; let call_await = if item_fn.sig.asyncness.is_some() { Some(quote::quote!(.await)) } else { None }; let def_struct = if !item_fn.sig.generics.params.is_empty() { let iter = item_fn .]]></description>
</item>
<item>
    <title>Rust实现Http Web Server</title>
    <link>https://847850277.github.io/posts/rust-http-server/mario-01/</link>
    <pubDate>Sun, 03 Nov 2024 10:00:00 &#43;0000</pubDate>
    <author>zhengpengde</author>
    <guid>https://847850277.github.io/posts/rust-http-server/mario-01/</guid>
    <description><![CDATA[用Rust实现WebSerer的第一篇 最近业余时间一直在学习Rust,也在尝试用Rust去造轮子。第一个轮子就是用Rust去实现Web服务器。Web服务器的核心流程就是Request 和 Response。 简单的总结就是解析请求，然后匹配到Server初始化的路由处理器，然后路由处理器处理完返回。
同步版本的程序 启动TCP服务 解析处理请求 匹配路由 返回响应 示范代码如下 use sync_core::server::Server; use sync_core::service::Service; fn main() { //trace log tracing_subscriber::fmt::init(); let mut server = Server::new(Service::new()); let route = sync_core::route::Route::new(&#34;GET&#34;.to_string(), &#34;/hello&#34;.to_string(), || { &#34;Hello World&#34;.to_string() }); // hello world 2 return int value let route2 = sync_core::route::Route::new(&#34;GET&#34;.to_string(), &#34;/hello2&#34;.to_string(), || { //i32 value return 42.to_string() }); // push route to server server.service.routes.push(route); server.service.routes.push(route2); server.start(); } use crate::service::Service; use log::info; use std::io::{Read, Write}; use std::net::{TcpListener, TcpStream}; pub struct Server { pub service: Service, } impl Server { pub fn new(service: Service) -&gt; Self { Self { service } } pub fn start(&amp;self) { let addr = &#34;127.]]></description>
</item>
</channel>
</rss>
