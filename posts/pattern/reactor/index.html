<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Reactor Pattern | ZhengPengDe Blog</title>
<meta name="keywords" content="">
<meta name="description" content="Intent 意图 The Reactor design pattern handles service requests that are delivered concurrently to an application by one or more clients. 反应器设计模式处理由一个或多个客户端并发传递到应用程序的服务请求, The application can register specific handlers for processing which are called by reactor on specific events. 应用程序可以注册用于处理的特定处理程序，这些处理程序由反应器在特定事件上调用 Dispatching of event handlers is performed by an initiation dispatcher, which manages the registered event handlers. 事件处理程序的分派由启动分派程序执行，该程序管理已注册的事件处理程序 Demultiplexing of service requests is performed by a synchronous event demultiplexer. 服务请求的解复用由同步事件解复用器执行 Class diagram 类图 Applicability 应用 Use Reactor pattern when 以下场景可以使用Reactor 模式">
<meta name="author" content="">
<link rel="canonical" href="https://847850277.github.io/posts/pattern/reactor/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.5cfc680b1eeaeef9efbced92d46c2a9e876b72ee14fba85846afc4cff9e6e6f8.css" integrity="sha256-XPxoCx7q7vnvvO2S1Gwqnodrcu4U&#43;6hYRq/Ez/nm5vg=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://847850277.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://847850277.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://847850277.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://847850277.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://847850277.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="Reactor Pattern" />
<meta property="og:description" content="Intent 意图 The Reactor design pattern handles service requests that are delivered concurrently to an application by one or more clients. 反应器设计模式处理由一个或多个客户端并发传递到应用程序的服务请求, The application can register specific handlers for processing which are called by reactor on specific events. 应用程序可以注册用于处理的特定处理程序，这些处理程序由反应器在特定事件上调用 Dispatching of event handlers is performed by an initiation dispatcher, which manages the registered event handlers. 事件处理程序的分派由启动分派程序执行，该程序管理已注册的事件处理程序 Demultiplexing of service requests is performed by a synchronous event demultiplexer. 服务请求的解复用由同步事件解复用器执行 Class diagram 类图 Applicability 应用 Use Reactor pattern when 以下场景可以使用Reactor 模式" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://847850277.github.io/posts/pattern/reactor/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2023-08-18T13:56:30+08:00" />
<meta property="article:modified_time" content="2023-08-18T13:56:30+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Reactor Pattern"/>
<meta name="twitter:description" content="Intent 意图 The Reactor design pattern handles service requests that are delivered concurrently to an application by one or more clients. 反应器设计模式处理由一个或多个客户端并发传递到应用程序的服务请求, The application can register specific handlers for processing which are called by reactor on specific events. 应用程序可以注册用于处理的特定处理程序，这些处理程序由反应器在特定事件上调用 Dispatching of event handlers is performed by an initiation dispatcher, which manages the registered event handlers. 事件处理程序的分派由启动分派程序执行，该程序管理已注册的事件处理程序 Demultiplexing of service requests is performed by a synchronous event demultiplexer. 服务请求的解复用由同步事件解复用器执行 Class diagram 类图 Applicability 应用 Use Reactor pattern when 以下场景可以使用Reactor 模式"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://847850277.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Reactor Pattern",
      "item": "https://847850277.github.io/posts/pattern/reactor/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Reactor Pattern",
  "name": "Reactor Pattern",
  "description": "Intent 意图 The Reactor design pattern handles service requests that are delivered concurrently to an application by one or more clients. 反应器设计模式处理由一个或多个客户端并发传递到应用程序的服务请求, The application can register specific handlers for processing which are called by reactor on specific events. 应用程序可以注册用于处理的特定处理程序，这些处理程序由反应器在特定事件上调用 Dispatching of event handlers is performed by an initiation dispatcher, which manages the registered event handlers. 事件处理程序的分派由启动分派程序执行，该程序管理已注册的事件处理程序 Demultiplexing of service requests is performed by a synchronous event demultiplexer. 服务请求的解复用由同步事件解复用器执行 Class diagram 类图 Applicability 应用 Use Reactor pattern when 以下场景可以使用Reactor 模式",
  "keywords": [
    
  ],
  "articleBody": "Intent 意图 The Reactor design pattern handles service requests that are delivered concurrently to an application by one or more clients. 反应器设计模式处理由一个或多个客户端并发传递到应用程序的服务请求, The application can register specific handlers for processing which are called by reactor on specific events. 应用程序可以注册用于处理的特定处理程序，这些处理程序由反应器在特定事件上调用 Dispatching of event handlers is performed by an initiation dispatcher, which manages the registered event handlers. 事件处理程序的分派由启动分派程序执行，该程序管理已注册的事件处理程序 Demultiplexing of service requests is performed by a synchronous event demultiplexer. 服务请求的解复用由同步事件解复用器执行 Class diagram 类图 Applicability 应用 Use Reactor pattern when 以下场景可以使用Reactor 模式\nA server application needs to handle concurrent service requests from multiple clients. 服务器应用程序需要处理来自多个客户机的并发服务请求 A server application needs to be available for receiving requests from new clients even when handling older client requests. 服务器应用程序需要能够接收来自新客户机的请求，即使在处理旧客户机请求时也是如此 A server must maximize throughput, minimize latency and use CPU efficiently without blocking. 服务器必须最大限度地提高吞吐量，最小化延迟并有效地使用CPU而不阻塞 Real world examples 真是使用项目 Spring Reactor 代码 Pattern Reactor Credits 参考 Douglas C. Schmidt - Reactor Pattern Oriented Software Architecture Volume 2: Patterns for Concurrent and Networked Objects Doug Lea - Scalable IO in Java Netty ",
  "wordCount" : "162",
  "inLanguage": "en",
  "datePublished": "2023-08-18T13:56:30+08:00",
  "dateModified": "2023-08-18T13:56:30+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://847850277.github.io/posts/pattern/reactor/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "ZhengPengDe Blog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://847850277.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://847850277.github.io/" accesskey="h" title="ZhengPengDe Blog (Alt + H)">ZhengPengDe Blog</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      Reactor Pattern
    </h1>
    <div class="post-meta"><span title='2023-08-18 13:56:30 +0800 CST'>August 18, 2023</span>

</div>
  </header> 
  <div class="post-content"><h2 id="intent-意图">Intent 意图<a hidden class="anchor" aria-hidden="true" href="#intent-意图">#</a></h2>
<ul>
<li>The Reactor design pattern handles service requests that are delivered concurrently to an application by one or more clients. 反应器设计模式处理由一个或多个客户端并发传递到应用程序的服务请求,</li>
<li>The application can register specific handlers for processing which are called by reactor on specific events. 应用程序可以注册用于处理的特定处理程序，这些处理程序由反应器在特定事件上调用</li>
<li>Dispatching of event handlers is performed by an initiation dispatcher, which manages the registered event handlers. 事件处理程序的分派由启动分派程序执行，该程序管理已注册的事件处理程序</li>
<li>Demultiplexing of service requests is performed by a synchronous event demultiplexer. 服务请求的解复用由同步事件解复用器执行</li>
</ul>
<h2 id="class-diagram-类图">Class diagram 类图<a hidden class="anchor" aria-hidden="true" href="#class-diagram-类图">#</a></h2>
<p><img loading="lazy" src="/img/source/pattern/reactor/reactor.png" alt="reactor"  />
</p>
<h2 id="applicability-应用">Applicability 应用<a hidden class="anchor" aria-hidden="true" href="#applicability-应用">#</a></h2>
<p>Use Reactor pattern when 以下场景可以使用Reactor 模式</p>
<ul>
<li>A server application needs to handle concurrent service requests from multiple clients. 服务器应用程序需要处理来自多个客户机的并发服务请求</li>
<li>A server application needs to be available for receiving requests from new clients even when handling older client requests. 服务器应用程序需要能够接收来自新客户机的请求，即使在处理旧客户机请求时也是如此</li>
<li>A server must maximize throughput, minimize latency and use CPU efficiently without blocking. 服务器必须最大限度地提高吞吐量，最小化延迟并有效地使用CPU而不阻塞</li>
</ul>
<h2 id="real-world-examples-真是使用项目">Real world examples 真是使用项目<a hidden class="anchor" aria-hidden="true" href="#real-world-examples-真是使用项目">#</a></h2>
<ul>
<li><a href="http://projectreactor.io/">Spring Reactor</a></li>
</ul>
<h2 id="代码">代码<a hidden class="anchor" aria-hidden="true" href="#代码">#</a></h2>
<ul>
<li><a href="https://github.com/847850277/mini-tool/tree/master/src/main/java/com/zp/designpattern/reactor">Pattern Reactor</a></li>
</ul>
<h2 id="credits-参考">Credits 参考<a hidden class="anchor" aria-hidden="true" href="#credits-参考">#</a></h2>
<ul>
<li><a href="https://www.dre.vanderbilt.edu/~schmidt/PDF/Reactor.pdf">Douglas C. Schmidt - Reactor</a></li>
<li><a href="https://www.amazon.com/gp/product/0471606952/ref=as_li_tl?ie=UTF8&amp;camp=1789&amp;creative=9325&amp;creativeASIN=0471606952&amp;linkCode=as2&amp;tag=javadesignpat-20&amp;linkId=889e4af72dca8261129bf14935e0f8dc">Pattern Oriented Software Architecture Volume 2: Patterns for Concurrent and Networked Objects</a></li>
<li><a href="http://gee.cs.oswego.edu/dl/cpjslides/nio.pdf">Doug Lea - Scalable IO in Java</a></li>
<li><a href="http://netty.io/">Netty</a></li>
</ul>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://847850277.github.io/">ZhengPengDe Blog</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
